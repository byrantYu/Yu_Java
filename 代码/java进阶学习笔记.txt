# 面向对象的三大特征

## 一 继承

### 为什么要有继承？

- 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

- 此处的多个类称为子类，单独的这个类称为父类（基类或超类）。可以理解为:“子类 is a 父类” 6"
- 类继承语法规则:

​      class Subclass extends Superclass{ }

### 继承的作用:

- 继承的出现提高了代码的复用性。
- 继承的出现让类与类之间产生了关系，提供了多态的前提。
- 不要仅为了获取其他类中某个功能而去继承

### 类的继承  

- 子类继承了父类，就继承了父类的方法和属性。
- 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。
- 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。

关于继承的规则：

- 子类不能直接访问父类中私有的(private)的成员变量和方法。
- Java只支持单继承，不允许多重继承
  - 一个子类只能有一个父类
  - 一个父类可以派生出多个子类

### 方法的重写

- 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。
- 要求：
  - 重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。
  - 重写方法不能使用比被重写方法更严格的访问权限。
  - 重写和被重写的方法须同时为static的，或同时为非static的
  - 子类方法抛出的异常不能大于父类被重写方法的异常

### 四种访问权限修饰符 

Java权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类对象成员的访问权限。 

| 修饰符    | 类内部 | 同一个包 | 子类 | 任何地方 |
| --------- | ------ | -------- | ---- | -------- |
| private   | Yes    |          |      |          |
| default   | Yes    | Yes      |      |          |
| protected | Yes    | Yes      | Yes  |          |
| public    | Yes    | Yes      | Yes  | Yes      |

对于class的权限修饰只可以用public和default。

- public类可以在任意地方被访问。

- default类只可以被同一个包内部的类访问。

### 关键字super 

在Java类中使用super来调用父类中的指定操作：

- super可用于访问父类中定义的属性
- super可用于调用父类中定义的成员方法
- super可用于在子类构造方法中调用父类的构造器

注意：

- 尤其当子父类出现同名成员时，可以用super进行区分
- super的追溯不仅限于直接父类
- super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

### 调用父类的构造器 

- 子类中所有的构造器默认都会访问父类中空参数的构造器
- 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行
- 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错

### this和super的区别 

| No.  | 区别点     | this                                                   | super                                    |
| ---- | ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 1    | 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 访问父类中的属性                         |
| 2    | 调用方法   | 访问本类中的方法                                       | 直接访问父类中的方法                     |
| 3    | 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，必须放在子类构造器的首行 |
| 4    | 特殊       | 表示当前对象                                           | 无此概念                                 |

## 二 多态 

### 面向对象特征之三：多态性 

- 多态性，是面向对象中最重要的概念，在java中有两种体现：

  1.方法的重载(overload)和重写(overwrite)。

  2.对象的多态性   ——可以直接应用在抽象类和接口上。

- Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。

- 若编译时类型和运行时类型不一致，就出现多态（Polymorphism）

### 

- 对象的多态 —在Java中,子类的对象可以替代父类的对象使用。
  - 一个变量只能有一种确定的数据类型
  - 一个引用类型变量可能指向(引用)多种不同类型的对象
- 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。
- 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法

### 多态小结

- 前提：
  - 需要存在继承或者实现关系
  - 要有覆盖操作

- 成员方法
  -  编译时：要查看引用变量所属的类中是否有所调用的方法。
  - 运行时：调用实际对象所属的类中的重写方法。
- 成员变量：
  - 不具备多态性，只看引用变量所属的类。

### 子类继承父类

- 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中
- 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量

# 面向对象的特性

## 对象类型转换 (Casting ) 

#### 基本数据类型的Casting：

- 自动类型转换：小的数据类型可以自动转换成大的数据类型

​        如long g=20;           double d=12.0f

- 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型

​        如 float f=(float)12.0;   int a=(int)1200L

#### 对Java对象的强制类型转换称为造型

- 从子类到父类的类型转换可以自动进行
- 从父类到子类的类型转换必须通过造型(强制类型转换)实现
- 无继承关系的引用类型间的转换是非法的
- 在造型前可以使用instanceof操作符测试一个对象的类型

##  Object 类 

- Object类是所有Java类的根父类

- 如果在类的声明中未使用extends关键字指明其父类，则默认父类为Object类 

### Object类中的主要方法 

| NO.  | 方法名称                              | 类型 | 描述           |
| ---- | ------------------------------------- | ---- | -------------- |
| 1    | public Object()                       | 构造 | 构造方法       |
| 2    | public   boolean   equals(Object obj) | 普通 | 对象比较       |
| 3    | public   int   hashCode()             | 普通 | 取得Hash码     |
| 4    | public   String toString()            | 普通 | 对象打印时调用 |

### ==操作符与equals方法 

= =： 

- 基本类型比较值:只要两个变量的值相等，即为true.

  ​      int a=5; if(a==6){…}

- 引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才返回true.

  ​    Person p1=new Person();   

  ​    Person p2=new Person();

​         if (p1==p2){…}

​	用“==”进行比较时，符号两边的数据类型必须兼	             容(可自动转换的基本数据类型除外)，否则编译出错



equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。

- 只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。   

    格式:obj1.equals(obj2)

- 特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；

- 原因：在这些类中重写了Object类的equals()方法。

### toString() 方法 

- toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。

- 在进行String与其它类型数据的连接操作时，自动调用toString()方法

- 可以根据需要在用户自定义类型中重写toString()方法

   如String 类重写了toString()方法，返回字符串的值。

- 基本类型数据转换为String类型时，调用了对应包装类的toString()方法

  

### 包装类(Wrapper)

- 针对八种基本定义相应的引用类型—包装类（封装类）
- 有了类的特点，就可以调用类中的方法。

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| boolean      | Boolean   |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| char         | Character |
| float        | Float     |
| double       | Double    |

- 基本数据类型包装成包装类  ---装箱 
- 获得包装类对象中包装的基本类型变量    ---拆箱 
- JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。

### 关键字static 

使用范围：

- 在Java类中，可用static修饰属性、方法、代码块、内部类

被修饰后的成员具备以下特点：

- 随着类的加载而加载
- 优先于对象存在
- 修饰的成员，被所有对象所共享
- 访问权限允许时，可不创建对象，直接被类调用

#### 类属性、类方法的设计思想 

- 类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些类属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。
- 如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用

### 类方法

- 没有对象的实例时，可以用类名.方法名()的形式访问由static标记的类方法。
- 在static方法内部只能访问类的static属性，不能访问类的非static属性。
- 因为不需要实例就可以访问static方法，因此static方法内部不能有this。(也不能有super ? YES!)
- 重载的方法需要同时为static的或者非static的。

### 设计模式

设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。 

### 类的成员之四：初始化块 

- 一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。
- static块通常用于初始化static (类)属性



- 非静态代码块：没有static修饰的代码块

  ​       1.可以有输出语句。

  ​       2.可以对类的属性、类的声明进行初始化   操作。

  ​       3.可以调用静态的变量或方法。

  ​       4.若有多个非静态的代码块，那么按照从上到下的顺序依次执行。

  ​       5.每次创建对象的时候，都会执行一次。且先于构造器执行



- 静态代码块：用static 修饰的代码块

  ​     1.可以有输出语句。

  ​     2.可以对类的属性、类的声明进行初始化操作。

  ​     3.不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。

  ​    4.若有多个静态的代码块，那么按照从上到下的顺序依次执行。

  ​    5.静态代码块的执行要先于非静态代码块。

  ​    6.静态代码块只执行一次

### 关键字：final 

在Java中声明类、属性和方法时，可使用关键字final来修饰,表示“最终”。

- final标记的类不能被继承。提高安全性，提高程序的可读性。 

- final标记的方法不能被子类重写。

- final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。    

  标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。

### 抽象类

随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。 



- 用abstract关键字来修饰一个类时，这个类叫做抽象类；
- 用abstract来修饰一个方法时，该方法叫做抽象方法。
- 抽象方法：只有方法的声明，没有方法的实现。以分号结束
- 含有抽象方法的类必须被声明为抽象类。
- 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。
- 不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法



### 接 口

- 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。

- 接口(interface)是抽象方法和常量值的定义的集合。

- 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。

- 实现接口类：

  ​		class SubClass implements InterfaceA{ }

- 一个类可以实现多个接口，接口也可以继承其它接口。

### 接口的特点：

- 用interface来定义。
- 接口中的所有成员变量都默认是由public static final修饰的。
- 接口中的所有方法都默认是由public abstract修饰的。
- 接口没有构造器。
- 接口采用多继承机制。

### 关于接口

- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。
- 接口的主要用途就是被实现类实现。（面向接口编程）
- 与继承关系类似，接口与实现类之间存在多态性
- 定义Java类的语法格式：先写extends，后写implements
- 如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类 
- 接口也可以继承另一个接口，使用extends关键字。
- 实现类SubAdapter必须给出接口SubInterface以及父接口MyInterface中所有方法的实现。

### 类的成员之五：内部类

- 在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。

- Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。

  ​	Inner class的名字不能与包含它的类名相同；

- Inner class可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要:内部类.成员或者内部类对象.成员。

- 分类：成员内部类（static成员内部类和非static成员内部类）

  ​      	    局部内部类（不谈修饰符）、匿名内部类

### 内部类特性

- nner class作为类的成员：

  - 可以声明为final的
  - 和外部类不同，Inner class可声明为private或protected；
  - Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；

- Inner class作为类：

  - 可以声明为abstract类 ，因此可以被其它的内部类继承

    【注意】非static的内部类中的成员不能声明为static的，只有在外部类或static的内部类中才可声明static成员。

### 匿名内部类 

匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。



# IO

### File 类 

- java.io.File类：文件和目录路径名的抽象表示形式，与平台无关

- File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。

- File对象可以作为参数传递给流的构造函数

- File类的常见构造方法：

  - public File(String pathname)

    ​         以pathname为路径创建File对象，可以是绝对路径或者相对路径

  - public File(String parent,String child)

    ​          以parent为父路径，child为子路径创建File对象。

- File的静态属性String separator存储了当前系统的路径分隔符。

  - 在UNIX中，此字段为‘/’，在Windows中，为‘\\’

