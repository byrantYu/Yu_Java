# java进阶

### 异常概念

A:异常:就是程序运行中出现的不正常的情况.

B:异常的由来:程序中的问题也是现实生活中的一个具体的事物,也可以通过java的类的形式进行描述,并封装成对象.

其实异常就是java对不正常情况描述后的对象体现.

### 异常的分类

A:异常的继承体系

  Throwable

​         Error (错误:一出现就是致命的)

​                服务器宕机,数据库崩溃等

​         Exception

​                RuntimeException(运行时异常,一般都是程序员犯的错误,需要修改源码的.)

​                编译时异常:在编译时必须进行处理,不处理无法通过编译.

### 异常的处理方式

#### try…catch处理单个异常

try…catch格式:

try{

​       需要检测的异常；

​    }  catch(异常类名异常变量) {

​       异常处理代码

​       可以调用异常的方法

​       通常我们只使用一个方法：printStackTrace打印异常信息

​    }

#### 使用throws关键字处理异常

 throws的方式处理异常

​              定义功能方法时，需要把出现的问题暴露出来让调用者去处理。那么就通过throws在方法上标识

 throws格式

修饰符 返回值类型 方法名(参数类型参数名1,参数类型参数名2...) **throws** **异常类名** {      }

#### try…catch处理个异常格式

try{

​       需要检测的异常；

​    } catch(异常类名1  异常变量1) {

​       异常处理代码

​       可以调用异常的方法

​       通常我们只使用一个方法：printStackTrace打印异常信息

​    } catch(异常类名2  异常变量2) {

​       异常处理代码

​       可以调用异常的方法

​       通常我们只使用一个方法：printStackTrace打印异常信息

​    }......//

可以有无数个

catch

### 异常在继承中的注意事项

 A:异常注意事项

​       a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)

​       b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常

​       c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws



### Eclipse导出API帮助文档

在eclipse使用时，可以配合文档注释，导出对类的说明文档，从而供其他人阅读学习与使用。

通过使用文档注释，将类或者方法进行注释用@简单标注基本信息。如@author 作者、@version代码版本、@param方法参数、@return方法返回值等。



### 自动拆装箱机制

自动拆箱:

\*      当希望使用基本数据类型时,可以给于基本数据类型包装类的对象.此时会自动由引用类型"拆箱"成了基本类型,再使用

 自动装箱:

\*      当希望使用基本数据类型包装类的对象时,可以给于基本数据类型的值.此时会自动由基本类型"装箱"成了引用类型的对象,再使用



### 正则表达式概述

正则表达式是专门解决字符串规则匹配的工具。

正则表达式也是一个字符串，用来定义匹配规则。

参照帮助文档，在Pattern类中有简单的规则定义，可以结合字符串类的方法使用。

###  迭代器概述

java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。

我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。

Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素；如果有，就把这个元素取出来，继续在判断；如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

集合中把这种取元素的方式描述在Iterator接口中。



# 多线程

### 线程与进程概念

进程：正在运行的程序。确切的来说，当一个程序进入内存运行，即是一个或多个进程在运行，具有一定独立功能。

线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。

### 继承Thread类创建线程

将类声明为Thread的子类。该子类重写Thread类的run方法。创建对象，开启线程。

开启线程的步骤：

​       1、指定线程执行目标：定义一个Thread类的子类，重写run方法，将相关逻辑实现

​              public void run() 线程要执行的业务逻辑方法，相当于该线程的"main方法"

​       2、创建自定义的线程子类对象

​       3、开启线程动作

​              public void start() 使该线程开始执行

### 实现Runnable接口创建线程

创建线程的另一种方法是声明实现 Runnable 接口的类，该类然后实现 run 方法。然后创建Runnable的实现类对象，传入到某个线程的构造方法中，开启线程。

Runnable接口用来指定每个线程要执行的任务。包含了一个 run 的无参数抽象方法，需要由接口实现类重写该方法。

开启线程的步骤：

​       1、指定线程执行目标：定义Runnable线程执行目标实现类，重写run方法，指定目标逻辑

​       2、通过指定线程执行目标的构造方法创建线程对象

​              public Thread(Runnable target)

​              a)创建线程执行目标对象

​              b)通过线程执行目标创建线程对象

​       3、开启线程动作 (start开启线程)

### 两种实现方式对比

继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。

实现Runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。

Runnable接口对线程对象和线程任务进行解耦。

A：第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。

B：实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。

###  线程生命周期

![1537530039086](C:\Users\student\AppData\Local\Temp\1537530039086.png)

在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。

线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。

### 多线程安全问题 

#### 产生原因分析 

当多个线程操作共享的数据时，共同修改该数据。

#### 利用同步代码块解决

Java中使用synchronized关键字来解决，将一个完整动作使用synchronized包裹。

同步代码块: 在代码块声明上，加上synchronized

synchronized (锁对象) {

​    可能会产生线程安全问题的代码

}

同步代码块中的锁对象可以是任意的对象；但多个线程操作相同数据时，要使用同一个锁对象才能够保证线程安全，避免安全问题。

### 多线程等待唤醒机制

多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。通过一定的手段使各个线程能有效的利用资源。而这种手段即——等待唤醒机制。 

等待唤醒机制所涉及到的方法：

​       wait()：等待，将正在执行的线程释放其执行资格和执行权，并存储到线程池中。

​      notify()：唤醒，唤醒线程池中被wait()的线程，一次唤醒一个，而且是任意的。

​       notifyAll()：唤醒全部，可以将线程池中的所有wait()线程都唤醒

### 死锁概述:

同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉



### IP地址&InetAddress

IP是每台电脑在互联网上的唯一标识符。

一个IPV4的地址是由四段0—255的数字组成：192.168.0.100。

Java中可以使用InetAddress类表示一个IP地址。

###  端口号

通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535，其中，0~1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。

### Scoket套接字

在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。

Socket就是为网络编程提供的一种机制，又叫套接字编程。Socket需要理解以下几点内容：

通信的两端都有Socket；

网络通信其实就是Socket间的通信；

数据在两个Socket间通过IO传输；

Socket编程一般使用TCP与UDP两种协议，这里主要介绍TCP。

### UDP协议

 UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。

由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输，例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。

### TCP协议

TCP协议通过三次握手协议将客户端与服务器端连接，两端使用各自的Socket对象。Socket对象中包含了IO流，供数据传输。

即：TCP协议在客户端与服务器端通过Socket组成了IO通道，数据在IO通道中传输，客户端传输的数据成队列方式写出，服务器端接收，同样服务器端传输的数据成队列方式写出，客户端接收。